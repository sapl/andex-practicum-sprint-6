# Задание 4. Проектирование продажи ОСАГО


## Обновленная схема
[Osago-Aggregator Diagram.drawio](https://viewer.diagrams.net/?lightbox=1&highlight=0000ff&nav=1&title=InsureTech_C4_Osago.drawio#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1g530ODgj4fFsryKIHbLVKONvBtzBWw3p%26export%3Ddownload)  

## API сервиса osago-aggregator

**API публикации заявки:**

```
POST /api/osago/requests
```
Request Body:
```JSON
{
  "owner": { "name": "Иванов Иван Иванович", "phone": "+79991234567", ... },
  "vehicle": {"model": "Camry", "year": 2020, ... },
  "companyIds": [1, 2, 3, 4, 5]
}
```
Response Body (ответ асинхронный сразу):
```JSON
{
  "requestId": "ccc148d3-7914-47fe-b6f6-ad5032a6a817"
}
```

**API получения статуса заявки:**

Long pooling API
```shell
GET /api/osago/requests/{requestId}?timeout=30`
```

Response Body:
```JSON
{
  "requestId": "ccc148d3-7914-47fe-b6f6-ad5032a6a817",
  "status": "pending",
  "offers": [
    {
      "id": "1d5032a6a114",
      "companyId": 1,
      "companyName": "Росгосстрах",
      "status": "pending"
    },
    {
      "id": "415032a6a516",
      "companyId": 2,
      "companyName": "Согласие",
      "status": "ready",
      "price": 15000,
      "tariff": "Premium"
    }
  ]
}
```

### Логика интеграции Web app + Core-Api + Osago-Aggregator

- API выше предоставляет сервис `osago-aggregator`
- Core-API публично для Webapp предоставляет такое же почти API только при отправке заявки
данные о пользователе и авто если есть берет из `client-info`
- Webapp отправляет запрос на Core-API и дожидается ответа через long-pooling (30сек таймаут)
как только появилось обновление о заявке (пришел ответ от одной из компаний)
запрос возвращает результат, UI обновляет список предложений и запускает снова тоот же запрос 
`GET /api/osago/requests/{requestId}` пока не получит статус `ready` от всех компаний или истечет таймаут в 60 секунд.
- Таким образом информация будет обновляться в реалтайме но без лишних запросов
  (если компаний 5 то запросов будет 5 в среднем на заявку)
- Далее пользователь может по requestId/offerId перейти к оформлению полиса используя имеющуюся заявку,
логика на стороне core-api 

### Реализация сервиса osago-aggregator

- Сервис `osago-aggregator` будет взаимодействовать с внешними API страховых компаний
  через их REST API
- Вероятно ему понадобится своя база данных для хранения заявок и статусов,
хотя  можно обойтись и Redis кешем, если `core-api` итак хранит данные о компаниях и продуктах
- При создании заявки создается requestId, который возвращается в ответе API
и публикуются задания в топик `osago-requests`, по одному на каждую компанию из списка `companyIds`
```JSON
{
  "requestId": "ccc148d3-7914-47fe-b6f6-ad5032a6a817", 
  "companyId": 1,
  "owner": { "name": "Иванов Иван Иванович", "phone": "+79991234567", ... },
  "vehicle": {"model": "Camry", "year": 2020, ... },
}
```
- При публикации используем `companyId` как ключ партиции, чтобы консюмеры распределялись
динамически по компаниям и долгие ответы API по одной из них не блокировали другие.

- Консумеры публикующие заявки разбирают завяки отправляя API запрос в компанию
и публикуют ответ в топик `osago-pending-results`, также с ключем партиции по companyId
```JSON
{
  "requestId": "ccc148d3-7914-47fe-b6f6-ad5032a6a817",
  "offerId": "xxx",
  "companyId": 1,
  "status": "pending",
  "expiresAt": "2021-09-01T12:00:00Z"
}
```
- Другие консюмеры осуществляют опрос по `offerId` в течении 60 секунд разбирая заявки
из `osago-pending-results` если запрос еще не готов и время не вышло (expiresAt),
то перепубликуем его в этот же топик. Повторный запрос не 
должен быть чаще чем раз в 3-5 секунд (если компания не поддерживает Long Pooling)
- Если пришел успешный ответ то обновляем исходный request (по requestId)
добавляя оффер по компании и уведомляем long pooling controller чтобы тот разблокировался 
и вернул обновление
- общий request для отдачи в API `GET /api/osago/requests/{requestId}` храним в базе или Redis

### Применение паттернов отказоустойчивости

**Timeout**
Может быть разным для разных API компаний, например 5 секунд.
Если API поддердживает Long pooling то может быть 30-60секунд.

**Retry**
Повторяем запросы при временных ошибках (например, сетевые сбои или временные 5xx).
Применяется при отправке завяки (2-3 ретрая). При получении статуса ретраи не нужны,
тк сама схема через топик предполагает их.

**Circuit Breaker**
Защищает от постоянных сбоев API страховых компаний.
Применяется в перед отправкой запроса на заявку или получения статуса к страховой компании.
Если API компании систематически возвращает ошибки или превышает тайм-ауты, запросы временно прекращаются.
А последующие заявки сразу отбиваются со `status=temporary_unavailable`.

**Rate Limiting**
Часть лимитов должна быть на уровне выше на `core-api` для защиты от ботов.
Может применяться также механизм защиты через Captcha.
сервис `osago-aggregator` также может иметь свои лимиты для дополнительной защиты от перегруза.

**Bulkhead**
Как выше описывалось используем Kafka партишининг по companyId.
Для каждой компании свой пул консюмеров, чтобы сбой одной компании не блокировал другие.
Дополнительно нужно предусмотреть автоматический ответ `status=temporary_unavailable` 
если очередь для конкретной компании переполнена.

**Автомасштабирование**
Предусмотреть автоматическое масштабирование сервиса `osago-aggregator` в кубернетис
увеличением числа реплик по метрие RPS. 